#!/usr/bin/ruby
# MacRuby AOT Compiler.
#
# This file is covered by the Ruby license.
#
# Copyright (C) 2009, Apple Inc

require 'optparse'
require 'rbconfig'

class Compiler
  NAME = File.basename(__FILE__)
  VALID_ARCHS = ['i386', 'x86_64']

  def initialize(argv)
    @mode = :normal
    @archs = []
    @frameworks = []
    @internal = argv.delete('--internal')

    # Parse arguments.
    OptionParser.new do |opts|
      opts.banner = "Usage: #{NAME} [options] file..."
      opts.on('-c', 'Compile and assemble, but do not link') { @dont_link = true }
      opts.on('-o <file>', 'Place the output into <file>') { |output| @output = output }
      #opts.on('--mode [MODE]', "Select compilation mode (normal or full)") { |mode| @mode = mode.intern }
      #opts.on('--framework <framework>', 'Link against <framework>') { |path| @frameworks << path }
      opts.on('--static', "Create a standalone static executable") { @static = true } 
      opts.on('-C', 'Compile, assemble and link a loadable object file') { @bundle = true }
      opts.on('-a', '--arch <ARCH>', 'Compile for specified CPU architecture') { |arch| @archs << arch }
      opts.on('-v', '--version', 'Display the version') { puts RUBY_DESCRIPTION; exit 1 }
      opts.on('-V', '--verbose', 'Print every command line executed') { @verbose = true }
      opts.on('-h', '--help', 'Display this information') { die opts }
      begin
        opts.parse!(argv)
      rescue OptionParser::InvalidOption => e
        die e, opts
      end
      die opts if argv.empty?
      @files = argv
      if @mode != :normal and @mode != :full
        die "Invalid mode `#{@mode}'. Possible choices are: normal, full"
      end
      @archs.uniq!
      @archs << RUBY_ARCH if @archs.empty?
      @archs.each do |arch|
        if not VALID_ARCHS.include?(arch)
          die "Invalid CPU architecture `#{arch}'. Possible values are: " + VALID_ARCHS.join(", ")
        end
      end
    end

    # Locate necessary programs.
    @macruby = locate(@internal ? './miniruby' : 'macruby')
    if @internal
      @llc = File.join(RbConfig::CONFIG['LLVM_PATH'], 'bin/llc')
      die "llc not found as #{@llc}" unless File.exist?(@llc)
    else
      @llc = locate('llc', true)
    end
    @gcc = locate('gcc')
    @gcxx = locate('g++')
    @nm = locate('nm')
    @lipo = locate('lipo')

    # Misc.
    @tmpdir = (ENV['TMPDIR'] or '/tmp')
    @tmpfiles = []
  end

  def run
    if @mode == :full
      die "Full compilation mode is not implemented yet!"
    end
    if @dont_link or @bundle
      die "Cannot specify --static when not building an executable" if @static
      die "Cannot specify -c and -C at the same time" if @bundle and @dont_link
      if @files.size > 1 and @output
        die "Cannot specify -o with -c or -C and multiple input files"
      end
      file = @files[0]
      if File.extname(file) != '.rb'
        die "Given input file `#{file}' must be a Ruby source file (.rb)"
      end
      if @bundle
        compile_bundle(file, @output)
      else
        compile_object(file, @output)
      end
    else
      objs = @files.map do |file|
        case File.extname(file)
          when '.rb'
            compile_object(file, nil)
          when '.o'
            die "Given input file `#{file} must exist" unless File.exist?(file)
            file
          else
            die "Given input file `#{file}' must be either a Ruby source file (.rb) or a Mach-O object file (.o)"
        end
      end
      compile_executable(objs, @output)
    end
  end

  def cleanup
    @tmpfiles.each { |x| File.delete(x) }
  end

  private

  def compile_object(path, output)
    base = File.basename(path, '.rb') 
    output ||= File.join(File.dirname(path), base + '.o')

    # Generate init function (must be unique).
    uuid = `uuidgen`.strip.gsub('-', '')
    init_func = "MREP_#{uuid}"

    tmp_objs = []
    @archs.each do |arch|
      # Compile the file into LLVM bitcode.
      bc = gen_tmpfile(base + arch, 'bc')
      execute("arch -#{arch} #{@macruby} --emit-llvm \"#{bc}\" #{init_func} \"#{path}\"")

      # Compile the bitcode as assembly.
      asm = gen_tmpfile(base + arch, 's')
      execute("#{@llc} -f \"#{bc}\" -o=\"#{asm}\" -march=#{llc_arch(arch)} -relocation-model=pic -enable-eh")

      # Compile the assembly.
      tmp_obj = gen_tmpfile(base + arch, 'o')
      execute("#{@gcc} -c -arch #{arch} \"#{asm}\" -o \"#{tmp_obj}\"")
      tmp_objs << tmp_obj
    end

    # Link the architecture objects.
    cli_tmp_objs = tmp_objs.map do |obj|
      '"' + obj + '"'
    end
    execute("#{@lipo} -create #{cli_tmp_objs.join(' ')} -output \"#{output}\"")

    [output, init_func]
  end

  def compile_bundle(file, output)
    base = File.basename(file, '.rb')
    obj = gen_tmpfile(base, 'o')
    obj, init_func = compile_object(file, obj)

    output ||= File.join(File.dirname(file), base + '.rbo')

    main_txt = <<EOS
extern "C" {
  void *#{init_func}(void *, void *);
  void *rb_vm_top_self(void);
  __attribute__((constructor)) static void __init__(void) {
    #{init_func}(rb_vm_top_self(), 0);
  }
}
EOS

    main = gen_tmpfile('main', 'c')
    File.open(main, 'w') { |io| io.write(main_txt) }
    linkf = @internal ? "-L. -lmacruby" : "-framework MacRuby"
    archf = @archs.map { |x| "-arch #{x}" }.join(' ')
    execute("#{@gcxx} \"#{main}\" -dynamic -bundle -undefined suppress -flat_namespace #{archf} #{linkf} \"#{obj}\" -o \"#{output}\"")
  end

  def compile_executable(objs_data, output)
    output ||= 'a.out'
    objs = []
    init_funcs = []
    objs_data.each { |obj, init_func| objs << obj; init_funcs << init_func }

    # Generate main file.
    main_txt = <<EOS
extern "C" {
    void ruby_sysinit(int *, char ***);
    void ruby_init(void);
    void ruby_set_argv(int, char **);
    void rb_vm_init_compiler(void);
    void *rb_vm_top_self(void);
    void rb_vm_print_current_exception(void);
    void rb_exit(int);
EOS
    init_funcs.each { |x| main_txt << "void *#{x}(void *, void *);\n" }
    main_txt << <<EOS
}

int main(int argc, char **argv)
{
    ruby_sysinit(&argc, &argv);
    if (argc > 0) {
	argc--;
        argv++;
    }
    ruby_init();
    ruby_set_argv(argc, argv);
    rb_vm_init_compiler();
    try {
        void *self = rb_vm_top_self();
EOS
    init_funcs.each { |x| main_txt << "#{x}(self, 0);\n" }
    main_txt << <<EOS
    }
    catch (...) {
	rb_vm_print_current_exception();
	rb_exit(1);
    }
    rb_exit(0);
}
EOS

    # Compile main file.
    main = gen_tmpfile('main', 'mm')
    File.open(main, 'w') { |io| io.write(main_txt) }
    main_o = gen_tmpfile('main', 'o')
    archf = @archs.map { |x| "-arch #{x}" }.join(' ')
    execute("#{@gcxx} \"#{main}\" -c #{archf} -o \"#{main_o}\" -fobjc-gc")
    objs.unshift(main_o)

    # Link all objects into executable.
    linkf = @static ? 
      "-L#{RbConfig::CONFIG['libdir']} #{RbConfig::CONFIG['LIBRUBYARG_STATIC_REALLY']}" :
      "-framework MacRuby -lobjc"
    line = "#{@gcxx} -o \"#{output}\" #{archf} #{linkf} "
    @frameworks.each { |f| line << "-framework #{f} " }
    objs.each { |o| line << " \"#{o}\"" }
    execute(line)
  end

  def execute(line)
    $stderr.puts line if @verbose
    ret = `#{line}`
    unless $?.success?
      die_str = "Error when executing `#{line}'"
      die_str += "\n#{ret}" unless ret.empty?
      die die_str
    end
    ret
  end

  def locate(progname, must_be_in_bindir=false)
    path = File.join(Config::CONFIG['bindir'], progname)
    unless File.exist?(path)
      if must_be_in_bindir
        die "Can't locate program `#{progname}' in #{Config::CONFIG['bindir']}"
      end
      path = `which #{progname}`.strip
      die "Can't locate program `#{progname}'" if path.empty?
    end
    path
  end

  def llc_arch(arch)
    # LLVM uses a different convention for architecture names.
    case arch
      when 'i386'; 'x86'
      when 'x86_64'; 'x86-64'
      else; arch
    end
  end

  def gen_tmpfile(base, ext)
    file = File.join(@tmpdir, "#{base}.#{ext}")
    @tmpfiles << file
    file
  end

  def die(*args)
    $stderr.puts args
    exit 1
  end
end

app = Compiler.new(ARGV)
begin
  app.run
ensure
  app.cleanup
end
